/**
 * Run Plan - Top-level plan for entire run (idea â†’ GA)
 * Spec: orchestrator.txt:51-53, UNIFIED_IMPLEMENTATION_SPEC.md Section 1.4
 *
 * RunPlan aggregates all phase plans, budgets, policies, and timeouts
 * for a complete idea-to-GA execution. Generated by RunPlanner.
 */

/**
 * Run Plan - Complete execution plan for all 12 phases
 */
export interface RunPlan {
  run_id: string;
  tenant_id: string;
  phases: PhasePlanSummary[];
  budgets: {
    total_tokens: number;
    total_tools_minutes: number;
    total_gpu_hours: number;
  };
  policies: {
    no_user_interactions: boolean;
    hallucination_guards_required: boolean;
    security_gates_required: string[]; // Phase IDs requiring security gates
  };
  timeouts: {
    total_timeout_hours: number;  // 20-50h
    phase_timeouts: Record<string, number>;  // hours per phase
  };
  required_evidence: string[];  // List of required evidence types
  created_at: string;
  version: string;  // For deterministic replay (semver)
}

/**
 * Phase Plan Summary - High-level phase metadata in RunPlan
 */
export interface PhasePlanSummary {
  phase: string;
  dependencies: string[];
  required_artifacts: string[];
  budgets: {
    tokens: number;
    tools_minutes: number;
  };
  timebox: string;  // ISO8601 duration
}

/**
 * Phase Plan - Detailed plan for single phase execution
 * Spec: phase.txt:172 (PhaseCoordinator builds Phase Plan)
 *
 * Derived from phase YAML config + runtime context
 */
export interface PhasePlan {
  phase: string;
  parallelism: 'sequential' | 'partial' | 'iterative' | number;
  agents: string[];
  tools: string[];
  guards: string[];
  rubrics: Record<string, any>;
  budgets: {
    tokens: number;
    tools_minutes: number;
  };
  timebox: string;
  refinery_config: {
    fission_min_coverage: number;
    fusion_min_consensus: number;
  };
  hash: string;  // SHA256(agents + rubrics + budgets) for deterministic replay
  version: string;
}

/**
 * Parse ISO8601 duration to milliseconds
 * Supports: PT1H, PT2H30M, PT45M, PT90S
 */
export function parseISO8601Duration(duration: string): number {
  const regex = /^PT(?:(\d+)H)?(?:(\d+)M)?(?:(\d+)S)?$/;
  const match = duration.match(regex);

  if (!match) {
    throw new Error(`Invalid ISO8601 duration: ${duration}`);
  }

  const hours = parseInt(match[1] || '0', 10);
  const minutes = parseInt(match[2] || '0', 10);
  const seconds = parseInt(match[3] || '0', 10);

  return (hours * 3600 + minutes * 60 + seconds) * 1000;
}

/**
 * Parse ISO8601 duration to hours (decimal)
 */
export function parseISO8601ToHours(duration: string): number {
  return parseISO8601Duration(duration) / (3600 * 1000);
}

/**
 * Convert hours to ISO8601 duration
 */
export function hoursToISO8601(hours: number): string {
  const totalMinutes = hours * 60;
  const h = Math.floor(totalMinutes / 60);
  const m = Math.floor(totalMinutes % 60);

  if (m === 0) {
    return `PT${h}H`;
  }
  return `PT${h}H${m}M`;
}
